<template>
  <div>
    <div class="field">
      <label class="label">State</label>
      <div class="control is-expanded">
        <div class="select is-fullwidth">
          <select v-model="dlState">
            <option value="any">Any</option>
            <option value="available">Available right now</option>
            <option value="downloaded">Downloaded</option>
            <option value="missing">Not downloaded</option>
          </select>
        </div>
      </div>
    </div>

    <label class="label">Sort by</label>
    <div class="field has-addons">
      <div class="control is-expanded">
        <div class="select is-fullwidth">
          <select v-model="sort">
            <option value="release_desc">↓ Release date</option>
            <option value="release_asc">↑ Release date</option>
            <option value="added_desc">↓ Date added</option>
            <option value="added_asc">↑ Date added</option>
            <option value="rating_desc">↓ Rating</option>
            <option value="rating_asc">↑ Rating</option>
            <option value="last_opened">↻ Recently viewed</option>
            <option value="random">↯ Random</option>
          </select>
        </div>
      </div>
    </div>

    <label class="label">Watch status</label>
    <div class="field has-addons">
      <div class="control is-expanded">
        <div class="select is-fullwidth">
          <select v-model="isWatched">
            <option value="">Everything</option>
            <option value="1">Watched</option>
            <option value="0">Unwatched</option>
          </select>
        </div>
      </div>
    </div>

    <div v-if="Object.keys(filters).length !== 0">
      <label class="label">Release date</label>
      <div class="field has-addons">
        <div class="control is-expanded">
          <div class="select is-fullwidth">
            <select v-model="releaseMonth">
              <option></option>
              <option v-for="t in filters.release_month" :key="t">{{t}}</option>
            </select>
          </div>
        </div>
        <div class="control">
          <button type="submit" class="button is-light" @click="clearReleaseMonth">
            <b-icon pack="fas" icon="times" size="is-small"></b-icon>
          </button>
        </div>
      </div>


      <label class="label">Cast</label>
      <div class="field">
        <b-taginput v-model="cast" autocomplete :data="filteredCast" @typing="getFilteredCast"></b-taginput>
      </div>

      <label class="label">Site</label>
      <div class="field">
        <b-taginput v-model="sites" autocomplete :data="filteredSites" @typing="getFilteredSites"></b-taginput>
      </div>

      <label class="label">Tags</label>
      <div class="field">
        <b-taginput v-model="tags" autocomplete :data="filteredTags" @typing="getFilteredTags"></b-taginput>
      </div>

    </div>
  </div>
</template>

<script>
  export default {
    name: "Filters",
    mounted() {
      this.$store.dispatch("sceneList/filters");
    },
    data() {
      return {
        filteredCast: [],
        filteredSites: [],
        filteredTags: [],
      }
    },
    methods: {
      getFilteredCast(text) {
        this.filteredCast = this.filters.cast.filter((option) => {
          return option.toString().toLowerCase().indexOf(text.toLowerCase()) >= 0
        })
      },
      getFilteredSites(text) {
        this.filteredSites = this.filters.sites.filter((option) => {
          return option.toString().toLowerCase().indexOf(text.toLowerCase()) >= 0
        })
      },
      getFilteredTags(text) {
        this.filteredTags = this.filters.tags.filter((option) => {
          return option.toString().toLowerCase().indexOf(text.toLowerCase()) >= 0
        })
      },
      clearReleaseMonth() {
        this.$store.state.sceneList.filters.releaseMonth = "";
        this.$store.dispatch("sceneList/load", {offset: 0});
      },
    },
    computed: {
      filters() {
        return this.$store.state.sceneList.filterOpts;
      },
      dlState: {
        get() {
          return this.$store.state.sceneList.filters.dlState;
        },
        set(value) {
          this.$store.state.sceneList.filters.dlState = value;

          switch (this.$store.state.sceneList.filters.dlState) {
            case "any":
              this.$store.state.sceneList.filters.isAvailable = "";
              this.$store.state.sceneList.filters.isAccessible = "";
              break;
            case "available":
              this.$store.state.sceneList.filters.isAvailable = "1";
              this.$store.state.sceneList.filters.isAccessible = "1";
              break;
            case "downloaded":
              this.$store.state.sceneList.filters.isAvailable = "1";
              this.$store.state.sceneList.filters.isAccessible = "";
              break;
            case "missing":
              this.$store.state.sceneList.filters.isAvailable = "0";
              this.$store.state.sceneList.filters.isAccessible = "";
              break;
          }

          this.$store.dispatch("sceneList/load", {offset: 0});
          this.$store.dispatch("sceneList/filters");
        }
      },
      releaseMonth: {
        get() {
          return this.$store.state.sceneList.filters.releaseMonth;
        },
        set(value) {
          this.$store.state.sceneList.filters.releaseMonth = value;
          this.$store.dispatch("sceneList/load", {offset: 0});
        }
      },
      cast: {
        get() {
          return this.$store.state.sceneList.filters.cast;
        },
        set(value) {
          this.$store.state.sceneList.filters.cast = value;
          this.$store.dispatch("sceneList/load", {offset: 0});
        }
      },
      sites: {
        get() {
          return this.$store.state.sceneList.filters.sites;
        },
        set(value) {
          this.$store.state.sceneList.filters.sites = value;
          this.$store.dispatch("sceneList/load", {offset: 0});
        }
      },
      tags: {
        get() {
          return this.$store.state.sceneList.filters.tags;
        },
        set(value) {
          this.$store.state.sceneList.filters.tags = value;
          this.$store.dispatch("sceneList/load", {offset: 0});
        }
      },
      sort: {
        get() {
          return this.$store.state.sceneList.filters.sort;
        },
        set(value) {
          this.$store.state.sceneList.filters.sort = value;
          this.$store.dispatch("sceneList/load", {offset: 0});
        }
      },
      isWatched: {
        get() {
          return this.$store.state.sceneList.filters.isWatched;
        },
        set(value) {
          this.$store.state.sceneList.filters.isWatched = value;
          this.$store.dispatch("sceneList/load", {offset: 0});
        }
      },
    }
  }
</script>
